const Queue = require('./PriorityQueue');
const removeDeepFromMap = require('./removeDeepFromMap');
const toDeepMap = require('./toDeepMap');
const validateDeep = require('./validateDeep');


class Graph {

  constructor(graph) {
    if (graph instanceof Map) {
      validateDeep(graph);
      this.graph = graph;
    } else if (graph) {
      this.graph = toDeepMap(graph);
    } else {
      this.graph = new Map();
    }
  } //create a graph object


  addNode(name, neighbors) {
    let nodes;
    if (neighbors instanceof Map) {
      validateDeep(neighbors);
      nodes = neighbors;
    } else {
      nodes = toDeepMap(neighbors);
    }

    this.graph.set(name, nodes);

    return this;
  }

  addVertex(name, neighbors) {
    return this.addNode(name, neighbors);
  }


  removeNode(key) {
    this.graph = removeDeepFromMap(this.graph, key);

    return this;
  }


  path(start, goal, options = {}) {
    // Don't run when we don't have nodes set
    if (!this.graph.size) {
      if (options.cost) return { path: null, cost: 0 };

      return null;
    }

    const explored = new Set();
    const frontier = new Queue();
    const previous = new Map();

    let path = [];
    let totalCost = 0;

    let avoid = [];
    if (options.avoid) avoid = [].concat(options.avoid);

    if (avoid.includes(start)) {
      throw new Error(`Starting node (${start}) cannot be avoided`);
    } else if (avoid.includes(goal)) {
      throw new Error(`Ending node (${goal}) cannot be avoided`);
    }

    // Add the starting point to the frontier, it will be the first node visited
    frontier.set(start, 0);

    // Run until we have visited every node in the frontier
    while (!frontier.isEmpty()) {
      // Get the node in the frontier with the lowest cost (`priority`)
      const node = frontier.next();  //removed it and get it out from queue

      // When the node with the lowest cost in the frontier in our goal node,
      // we can compute the path and exit the loop
      if (node.key === goal) {
        // Set the total cost to the current value
        totalCost = node.priority;

        let nodeKey = node.key;
        while (previous.has(nodeKey)) {
          path.push(nodeKey);
          nodeKey = previous.get(nodeKey);
        }
        break;
      }

      // Add the current node to the explored set
      explored.add(node.key);

      // Loop all the neighboring nodes
      const neighbors = this.graph.get(node.key) || new Map();
      neighbors.forEach((nCost, nNode) => {
        // If we already explored the node, or the node is to be avoided, skip it
        if (explored.has(nNode) || avoid.includes(nNode)) return null;

        // If the neighboring node is not yet in the frontier, we add it with
        // the correct cost
        if (!frontier.has(nNode)) {
          previous.set(nNode, node.key);
          return frontier.set(nNode, node.priority + nCost);
        } //return back to while loop.

        const frontierPriority = frontier.get(nNode).priority;
        const nodeCost = node.priority + nCost;

        // Otherwise we only update the cost of this node in the frontier when
        // it's below what's currently set
        if (nodeCost < frontierPriority) {
          previous.set(nNode, node.key);
          return frontier.set(nNode, nodeCost);
        }

        return null;
      });//always contain only one path from one node to another
      //the reason is that since the node is already contained in the frontier
      // therefore, we want to compare the cost between one in the frontier and the current one I am looking at
      // if the current one has lower cost, replace the one in the forntier with the current one I am looking at
      // therefore, the forntier will only contained one path that has lower cost.
       //else, do not replace it, just return nothing ,the frontier is not changed.
    }

function fixed_path(path){
    if (!path.length) {
      if (options.cost) return { path: null, cost: 0 };

      return null;
    }

    if (options.trim) {
      path.shift();
    } else {
      // Add the origin waypoint at the end of the array
      path = path.concat([start]);
    }

    // Reverse the path if we don't want it reversed, so the result will be
    // from `start` to `goal`
    if (!options.reverse) {
      path = path.reverse();
    }

    // Return an object if we also want the cost
    if (options.cost) {
      return {
        path,
        cost: totalCost,
      };
    }
}
    return fixed_path(path);
  }

  //******************************************
  allpath(start, goal, options = {}) {   //ONLY WORKS FOR NON CYCLED PATHS
    // Don't run when we don't have nodes set
    if (!this.graph.size) {
      if (options.cost) return { path: null, cost: 0 };

      return null;
    }

    const explored = new Set();
    const frontier = new Queue();
    const previous = new Map();

    let path = [];
    let totalCost = 0;

    let avoid = [];
    if (options.avoid) avoid = [].concat(options.avoid);

    if (avoid.includes(start)) {
      throw new Error(`Starting node (${start}) cannot be avoided`);
    } else if (avoid.includes(goal)) {
      throw new Error(`Ending node (${goal}) cannot be avoided`);
    }


    frontier.set(start, 0);
    var i = 0;
    let allpath = [];

    // Run until we have visited every node in the frontier
    while (!frontier.isEmpty()) {
      // console.log('///////////////NEW Round//////////////////');
      // console.log(frontier);
      const node = frontier.next();  //removed it and get it out from queue

      if(node.key!=goal){
        explored.add(node.key);
      }

      // Loop all the neighboring nodes
      const neighbors = this.graph.get(node.key) || new Map();
      // console.log('Neighbors');
      // console.log(neighbors);
      neighbors.forEach((nCost, nNode) => {
        // If we already explored the node, or the node is to be avoided, skip it
        if (explored.has(nNode) || avoid.includes(nNode)) return null;
        // if(previous.has(nNode) || avoid.includes(nNode)) return null;
          // console.log(nNode);
          previous.set(nNode, node.key);
          // console.log('PREVIOUS');
          // console.log(previous);
          if(previous.has(goal)){
            // console.log('true');
          let nodeKey = goal;
          const duplicate = new Set();


          while (previous.has(nodeKey)) {   //OUOTPUT start from here
            totalCost = node.priority + nCost;
            if(duplicate.has(nodeKey)){
              break;
            }
            path.push(nodeKey);
            duplicate.add(nodeKey);
            nodeKey = previous.get(nodeKey);
          }
          var current = path;
          allpath[i] = fix_path(current);
          // console.log(allpath[i]);
          i += 1;
          path = [];
          previous.delete(goal);
          // console.log('AFTER REMOVE');
          // console.log(previous);
        }
        return frontier.set(nNode, node.priority + nCost);
        return null;
      });
    }  //END OF WHILE


  function fix_path(path){
    if (!path.length) {
      if (options.cost) return { path: null, cost: 0 };

      return null;
    }
    if (options.trim) {
      path.shift();
    } else {
      path = path.concat([start]);
    }

    if (!options.reverse) {
      path = path.reverse();
    }

    if (options.cost) {
      return {
        path,
        cost: totalCost,
      };
    }
    return path;
  }

    return allpath;
  }
  //******************************************

  /**
   * @deprecated since version 2.0, use `Graph#path` instead
   */
  shortestPath(...args) {
    return this.path(...args);
  }

}

module.exports = Graph;
